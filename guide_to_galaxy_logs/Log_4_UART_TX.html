---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Log 3: The Synchronous FIFO</title>
    <style>
        :root {
            --space-black: #0b0e14;
            --deep-slate: #161b22;
            --nebula-purple: #6e40c9;
            --star-blue: #58a6ff;
            --stardust: #e6edf3;
            --border-color: #30363d;
            --code-bg: #0d1117;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--stardust);
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: radial-gradient(circle at center, #1a1f2e 0%, var(--space-black) 100%);
            background-attachment: fixed;
        }
        h1, h2, h3, h4 { color: var(--star-blue); margin-top: 1.5em; }
        
        .log-container {
            background-color: var(--deep-slate);
            padding: 40px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* SECTION STYLING */
        .section {
            padding-bottom: 20px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }
        .section:last-of-type { border-bottom: none; }

        .back-link { 
            margin-bottom: 20px; 
            display: inline-block; 
            text-decoration: none; 
            color: var(--nebula-purple); 
            font-weight: bold; 
            transition: color 0.2s;
        }
        .back-link:hover { color: var(--star-blue); }
        
        details {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }
        summary { cursor: pointer; font-weight: bold; color: var(--star-blue); outline: none; }
        pre { 
            white-space: pre-wrap; 
            word-wrap: break-word; 
            font-family: 'Consolas', 'Courier New', monospace; 
            font-size: 14px; 
            color: #d1d5db;
            margin: 0;
        }
        code { background: #21262d; padding: 2px 5px; border-radius: 4px; color: var(--star-blue); font-family: 'Consolas', monospace; }
        ul { padding-left: 20px; }
        li { margin-bottom: 8px; }
        blockquote { border-left: 4px solid var(--nebula-purple); margin: 20px 0; padding-left: 15px; font-style: italic; }
        a { color: var(--star-blue); text-decoration: none; }
        a:hover { text-decoration: underline; }

       /* Brighter "Nebula Frost" Table Styling */

       /* Center the image and its caption */
        .image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 30px auto;
            width: 100%;
        }

        .interface-table-wrapper {
            margin: 25px 0;
            border-radius: 8px;
            overflow: hidden;
            /* Uses a softer, lighter border for a clean look */
            border: 1px solid #d0d7de; 
            /* Soft light-mode shadow for depth */
            box-shadow: 0 8px 24px rgba(140, 149, 159, 0.2);
        }

        .interface-table {
            width: 100%;
            border-collapse: collapse;
            /* Main body is a very clean, bright off-white/grey */
            background-color: #f6f8fa; 
            color: #24292f;
            font-size: 0.95rem;
        }

        .interface-table th {
            /* Header uses a sophisticated slate-grey */
            background-color: #eaeef2;
            color: #8a3ffc; /* Vivid Nebula Purple */
            font-weight: 700;
            text-align: center;
            padding: 14px 16px;
            border-bottom: 2px solid #d0d7de;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .interface-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #d0d7de;
            text-align: center;
            vertical-align: middle;
        }

        /* Subtle Zebra Striping using a crisp white */
        .interface-table tr:nth-child(even) {
            background-color: #ffffff;
        }

        /* Row highlight on hover - a very light purple tint */
        .interface-table tr:hover {
            background-color: #f0f7ff;
        }

        /* Logic/Signal Styling - Professional "GitHub-style" Code look */
        .interface-table code {
            background-color: rgba(175, 184, 193, 0.2); /* Soft grey inset */
            color: #0969da;           /* Precision Blue for signals */
            padding: 3px 8px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
            display: inline-block;
        }

        /* Status Column - Vibrant Verification Green */
        .interface-table td:nth-child(2) {
            font-weight: bold;
            color: #1a7f37; 
        }
        
        /* Image Zoom Styling */
        .clickable-img {
            cursor: zoom-in;
            transition: transform 0.2s;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            border-radius: 8px;
        }
        .clickable-img:hover { transform: scale(1.01); }
        .img-caption { color: #8b949e; font-size: 0.85rem; margin-top: 10px; font-style: italic; }

        /* --- ADDITIONS FOR ENLARGING & ZOOMING --- */
        .img-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: none; /* Controlled by Script */
            justify-content: center;
            align-items: center;
            z-index: 9999;
            cursor: zoom-out;
            overflow: hidden; /* Prevents scrollbars during zoom */
        }

        .img-overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            transition: transform 0.1s ease-out; /* Smooth scrolling zoom */
            transform-origin: center; /* Ensures zoom happens from middle */
        }
        
        /* Math/LaTeX Styling */
        .mjx-chtml {
            color: #adbac7; /* Matches your document text color */
            font-size: 1.1em;
            margin: 20px 0;
        }
        
        /* Ensure display equations are centered and spaced */
        .MathJax_Display {
            margin: 25px 0 !important;
            display: block;
            text-align: center;
        }
            </style>
        </head>
        <body>
    
        <div class="log-container">
    <a href="https://tomerhabany.github.io/Chip_design_journey/" class="back-link">← Back to Portfolio</a>
    <div class="section">
        <h1 class="center">Log 4: The UART Transmitter – Precision Timing & State Machines</h1>
        <p>In our previous log, we mastered data buffering with the FIFO. Now, we will build the bridge that sends that data out of our chip. We are moving into communication protocols, starting with the UART (Universal Asynchronous Receiver-Transmitter). Specifically, we will focus on the Transmitter (TX) side.</p>
    </div>

    <div class="section">
    <h2>RTL Module: UART Transmitter &amp; Baud Rate Generator</h2>

    <h3>What is a UART?</h3>
    <p>UART (Universal Asynchronous Receiver-Transmitter) is one of the most fundamental communication protocols in digital design. UART is asynchronous, meaning it does not share a clock signal between the sender and the receiver.</p>
    
    <p>In most systems, the CPU or the internal FPGA logic operates at a very high frequency (often 50MHz, 100MHz, or higher). However, when communicating with outside components such as a GPS module, a sensor, or a PC terminal, those devices typically operate at a much slower frequency to ensure data integrity over wires.</p>

    

    <p>To bridge this gap, the UART acts as a translator:</p>
    <ul>
        <li><strong>Parallel-to-Serial Conversion:</strong> It takes a full Byte (8 bits) of data from the CPU all at once (parallel) and sends it out one bit at a time (serial) over a single wire.</li>
        <li><strong>Timing Alignment:</strong> Because there is no shared clock, both sides must agree on a specific speed beforehand, known as the Baud Rate.</li>
    </ul>

    <p>To achieve this, the transmitter must:</p>
    <ul>
        <li>Generate its own timing signal to know exactly when to shift each bit out onto the wire.</li>
        <li>Package data into a "frame" (Start bit, Data bits, and a Stop bit) so the receiver knows when a transmission begins and ends.</li>
    </ul>

    <p>This guide is split into two parts: First, we will build the "heartbeat" of the system - the Baud Rate Generator, and then we will implement the UART Transmitter state machine that uses it.</p>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">

    <h2>Part 1: The Baud Rate Generator (baud_gen.sv)</h2>

    <h4>1. The Functional Specification</h4>
    <p><strong>Purpose:</strong> To create a timing pulse (tick) that tells the UART module when to sample or shift data bits based on a pre-defined frequency.</p>

    <p><strong>Behavior:</strong></p>
    <ul>
        <li>Divides the high-frequency system clock down to a much slower "sample rate."</li>
        <li>In this design, we generate a tick that is 16 times faster than the actual Baud Rate. This is a common industry standard because it allows the Receiver (RX) to oversample the incoming data for better accuracy.</li>
        <li>Provides a <code>sample_tick</code> that is high for exactly one clock cycle when the timing limit is reached.</li>
        <li>Includes an <code>en</code> (enable) signal to start or stop the generator.</li>
    </ul>

    <h4>Interface Definition</h4>
    <div class="interface-table-wrapper">
        <table class="interface-table">
            <thead>
                <tr>
                    <th>Signal Name</th>
                    <th>Direction</th>
                    <th>Width</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>clk</code></td><td>Input</td><td>1</td><td>System clock (e.g., 100MHz).</td></tr>
                <tr><td><code>rst_n</code></td><td>Input</td><td>1</td><td>Active-low asynchronous reset.</td></tr>
                <tr><td><code>en</code></td><td>Input</td><td>1</td><td>Enable signal to start the counter.</td></tr>
                <tr><td><code>sample_tick</code></td><td>Output</td><td>1</td><td>High for one cycle at the oversampling rate.</td></tr>
            </tbody>
        </table>
    </div>

    <p>The <code>en</code> signal is crucial for maintaining synchronization. Since UART is asynchronous, the transmitter and receiver need to start their "stopwatches" at the exact same moment a transmission begins. By keeping the generator disabled until the UART state machine is ready to send a Start Bit, we ensure that the very first tick occurs at a predictable interval, preventing timing drift from the very first bit.</p>

            <h4>Module Header</h4>
            <details>
                <summary>View Module Header Code</summary>
                <pre><code class="language-systemverilog">
        module baud_gen #(
            parameter CLOCK_FREQ = 100_000_000, // 100 MHz
            parameter BAUD_RATE  = 115_200
        ) (
            input  logic clk,
            input  logic rst_n,
            input  logic en,
            output logic sample_tick
        );
                </code></pre>
            </details>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">
    
    <h4>2. Baud Generator Architecture</h4>
    <p>To manage the timing logic, we must define the parameters and internal registers that control the frequency division.</p>
    <ul>
        <li><code>TICK_LIMIT</code>: A calculated constant that defines how many system clock cycles must pass to equal one "tick" period.</li>
        <li><code>TICK_WIDTH</code>: The minimum number of bits required to represent the <code>TICK_LIMIT</code> value.</li>
        <li><code>tick_count</code>: The internal counter that tracks elapsed clock cycles. When this reaches the <code>TICK_LIMIT</code>, a tick is generated and the counter resets.</li>
    </ul>
    <p>To create an accurate timing pulse, we need to calculate the divider ratio.</p>
    <p><strong>The Math:</strong> Since we want 16 ticks per baud bit, the formula used for the tick limit is:</p>
    
    <div class="math-container">
        \[ \text{TICK_LIMIT} = \frac{\text{CLOCK_FREQ}}{\text{BAUD_RATE} \times 16} \]
    </div>
    
    <p>For a 100MHz clock and 115,200 Baud:</p>
    
    <div class="math-container">
        \[ \text{TICK_LIMIT} = \frac{100,000,000}{115,200 \times 16} \approx 54.25 \]
    </div>
    
    <p>The counter will count from 0 to 53 (54 total steps) to approximate this timing.</p>
   
    <p><strong>Bit-Width Calculation:</strong> We use <code>TICK_WIDTH = clog2(TICK_LIMIT)</code> to ensure the <code>tick_count</code> register is exactly the right size to hold the maximum value of the limit.</p>
    <details>
        <summary>View Parameters and Internal Signals</summary>
        <pre><code class="language-systemverilog">
    // Calculate the number of clock cycles per baud tick
    localparam integer TICK_LIMIT = CLOCK_FREQ / (BAUD_RATE*16);
    localparam integer TICK_WIDTH = $clog2(TICK_LIMIT);

    // count signal
    logic [TICK_WIDTH-1:0] tick_count;
        </code></pre>
    </details>

    <p>We use <code>localparam</code> for these values because they are derived constants. Unlike the <code>parameter</code> values in the module header, which the user can change during instantiation, a <code>localparam</code> cannot be modified from the outside. This protects the design by ensuring the math remains consistent with the provided clock and baud rate.</p>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">
    
    <h4>3. How the Generator Works (Step-by-Step)</h4>
    <p>Imagine the system is configured for 115,200 Baud on a 100MHz clock. We can trace how the hardware responds by looking at the logical flow of the module:</p>
    
    <p><strong>Scenario 1: Reset or Disabled</strong></p>
    <p>If <code>rst_n</code> is low or <code>en</code> is low, the logic enters a "forced idle" state. The <code>tick_count</code> is cleared to 0 and <code>sample_tick</code> stays at 0. The "heartbeat" is stopped.</p>
    
    <p><strong>Scenario 2: Normal Counting</strong></p>
    <p>When the module is enabled, <code>tick_count</code> increments by 1 on every rising edge of <code>clk</code>. It acts as a stopwatch counting system clock cycles.</p>
    
    <p><strong>Scenario 3: Reaching the Limit (The Tick)</strong></p>
    <p>Once <code>tick_count</code> reaches the threshold (<code>TICK_LIMIT - 1</code>, which is 53 in our example), it wraps back to 0 on the next clock edge. At that exact moment, <code>sample_tick</code> is driven to 1 for that single clock cycle. This "tick" acts as a strobe for the UART state machine we will build next.</p>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">
    
    <h4>4. Implementation</h4>
    
    <p>To translate our requirements into hardware, we utilize an <code>always_ff</code> procedural block to model synchronous, edge-triggered behavior. This section of the code is responsible for managing the three distinct operational states of the generator:</p>
    <ul>
        <li>
        <strong>Asynchronous Reset <code>(!rst_n)</code>:</strong> We use a high-priority check for the reset signal. This ensures that the <code>tick_count</code> and <code>sample_tick</code> are immediately forced to zero, putting the system in a known, safe state regardless of the clock.
        </li>
        <li>    
        <strong>Synchronous Enable <code>(!en)</code>:</strong> The logic explicitly checks the enable signal on every clock edge. By resetting the <code>tick_count</code> to zero whenever en is low, we ensure that the "stopwatch" starts from a clean slate the moment the UART transmission begins. This prevents the first bit from being shorter than the others - which can cause an entire transmission to be lost.
        </li>
        <li>
        <strong>The Rollover Comparator:</strong> The heart of the implementation is a conditional check: if <code>(tick_count == TICK_LIMIT - 1)</code>. When this condition is met, the code performs two simultaneous actions: it wraps the counter back to 0 and drives <code>sample_tick</code> high for one cycle.
        </li>
        <p>
        The following code implements this logic using non-blocking assignments (<=), which is essential for modeling sequential logic accurately in SystemVerilog.</p>
        </p>
    </ul>
    <details>
        <summary>View Baud Generator Code</summary>
        <pre><code class="language-systemverilog">
    // baud tick generation and counter logic
    always_ff @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            tick_count <= '0;
            sample_tick <= 1'b0;
        end else if(!en) begin
            tick_count <= '0;
            sample_tick <= 1'b0; // no tick when disabled
        end else begin                
            if(tick_count == TICK_LIMIT - 1) begin
                tick_count <= '0;
                sample_tick <= 1'b1; // generate sample tick
            end else begin
                tick_count <= tick_count + 1;
                sample_tick <= 1'b0;  // no tick     
            end
        end
    end
        </code></pre>
    </details>

    <p>The Baud Rate Generator is now complete. In the next section, we will implement the UART Transmitter, which will "listen" to the <code>sample_tick</code> to know when to shift data out onto the TX line.</p>
</div>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">
    
    
<div class="section">
    <h2>RTL Module: UART Transmitter (uart_tx.sv)</h2>
    
    <h3>Introduction</h3>
    <p>The UART Transmitter is the subsystem responsible for executing the outbound leg of asynchronous serial communication. Its primary role is to act as a serializer: it accepts a multi-bit parallel data word from the system's internal bus and systematically broadcasts it over a single physical wire. Beyond simple data movement, the transmitter is the "protocol architect", it enforces the UART standard by encapsulating raw data into a structured frame, adding the necessary start and stop bits that allow a remote receiver to synchronize and capture the data without a shared clock signal.</p>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">
    
   <h3>Component Interactivity</h3>
    <p>Before diving into the RTL, it is important to understand how the transmitter sits within a larger system. It acts as the bridge between the high-speed internal logic (CPU/FPGA) and the external serial world.</p>
        
    <div class="image-container">
        <img src="images/system_block_diagram.png" alt="System Block Diagram">
        <p class="figure-caption">Figure 1: UART System Block Diagram</p>
    </div>

    <p>In Figure 1 we can see the relationship between CPU, Baud Generator, and Transmitter </p>
    

    
    <p>To ensure successful data transmission, four distinct entities must work in concert:</p>
    <ul>
        <li><strong>The CPU/Control Logic:</strong> This is the master of the operation. It provides the parallel data (<code>din</code>) and pulses the start signal (<code>tx_start</code>). To prevent data corruption, the CPU must not send new data while a transmission is in progress. The done signal (<code>tx_done</code>) acts as a critical feedback pulse (or "handshake"), informing the CPU that the previous frame is complete and the transmitter is ready for the next byte.</li>
        <li><strong>The Baud Rate Generator:</strong> This serves as the system "metronome." It remains idle until the Transmitter enables it via the <code>baud_en</code> signal. Once active, it sends steady sample ticks to the transmitter, ensuring that every bit sent out onto the wire has a consistent and accurate duration (the bit period).</li>
        <li><strong>The UART Transmitter (The Bridge):</strong> This module manages the state machine. It consumes the parallel data from the CPU and uses the timing from the Baud Generator to "shift" that data out one bit at a time. It is responsible for wrapping the raw data in a Start bit and a Stop bit.</li>
        <li><strong>The External Receiver:</strong> This is the destination. It sits at the other end of the <code>tx_out</code> wire, waiting for the signal to drop from High to Low (the Start Bit) so it can begin sampling the incoming serial data.</li>
    </ul>

    <p>A standard transmission frame consists of:</p>
    <ul>
        <li><strong>Start Bit (Logic 0):</strong> Signals the receiver to start its clock.</li>
        <li><strong>Data Bits:</strong> Usually 8 bits, sent Least Significant Bit (LSB) first.</li>
        <li><strong>Stop Bit (Logic 1):</strong> Signals the end of the frame.</li>
    </ul>

    <h4>Transmission Pattern Example:</h4>
    <p>To transmit the character 'A' (ASCII 0x41 / Binary 01000001), the serial line transitions through the following frame structure:</p>

    <div class="interface-table-wrapper">
        <table class="interface-table">
            <thead>
                <tr>
                    <th>State</th>
                    <th>Idle</th>
                    <th>Start</th>
                    <th>D0 (LSB)</th>
                    <th>D1</th>
                    <th>D2</th>
                    <th>D3</th>
                    <th>D4</th>
                    <th>D5</th>
                    <th>D6</th>
                    <th>D7 (MSB)</th>
                    <th>Stop</th>
                    <th>Idle</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Logic</strong></td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>0</td>
                    <td>1</td>
                    <td>0</td>
                    <td>1</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td><strong>Bit #</strong></td>
                    <td>-</td>
                    <td>-</td>
                    <td>1</td>
                    <td>2</td>
                    <td>3</td>
                    <td>4</td>
                    <td>5</td>
                    <td>6</td>
                    <td>7</td>
                    <td>8</td>
                    <td>-</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>
    </div>

    <p><strong>Visual Sequence:</strong><br>
    [IDLE: 1] → [START: 0] → [DATA: 10000010] → [STOP: 1]</p>
    
    <blockquote>
        Note: The <code>tx_done</code> signal pulses high immediately after the Stop bit duration is complete, signaling the CPU to prepare the next frame.
    </blockquote>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">

    <h3>Part 2: The UART Transmitter Module</h3>
    <p>The following section defines the physical and logical interface of the module. As illustrated in the System Block Diagram above, these signals facilitate the handshake between the CPU and the Baud Generator.</p>

    <h4>Interface Definition</h4>
    <div class="interface-table-wrapper">
        <table class="interface-table">
            <thead>
                <tr>
                    <th>Signal Name</th>
                    <th>Direction</th>
                    <th>Width</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>clk</code></td><td>Input</td><td>1</td><td>System clock.</td></tr>
                <tr><td><code>rst_n</code></td><td>Input</td><td>1</td><td>Active-low reset.</td></tr>
                <tr><td><code>din</code></td><td>Input</td><td>DATA_WIDTH</td><td>The parallel byte to be sent.</td></tr>
                <tr><td><code>tx_start</code></td><td>Input</td><td>1</td><td>Triggers the transmission process.</td></tr>
                <tr><td><code>sample_tick</code></td><td>Input</td><td>1</td><td>The "heartbeat" from the Baud Rate Generator.</td></tr>
                <tr><td><code>tx_out</code></td><td>Output</td><td>1</td><td>The serial output line.</td></tr>
                <tr><td><code>tx_done</code></td><td>Output</td><td>1</td><td>High for one cycle after the Stop bit finishes.</td></tr>
                <tr><td><code>baud_en</code></td><td>Output</td><td>1</td><td>Enables the Baud Generator during active transmission.</td></tr>
            </tbody>
        </table>
    </div>

    <p>According to our interface definition table we declare the module and its ports. Additionally we declare two parameters <code>DATA_WIDTH</code> and <code>TICKS_PER_BIT</code> to keep our model adjustable</p>
    <details>
        <summary>View Module Header Code</summary>
<pre><code class="language-systemverilog">
module uart_tx #(
    parameter TICKS_PER_BIT = 16, // Number of baud ticks per bit
    parameter DATA_WIDTH    = 8   // Number of data bits
) (
    input  logic                   clk,
    input  logic                   rst_n,
    input  logic [DATA_WIDTH-1:0]  din,
    input  logic                   tx_start,
    input  logic                   sample_tick,
    output logic                   tx_out,
    output logic                   tx_done,
    output logic                   baud_en
);
</code></pre>
    </details>
    
    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">

    <h4>2. Internal Signals and Registers</h4>
    <p>The transmitter is implemented as a Registered State Machine. This architecture uses a "Next State / Register" logic pattern to ensure timing stability. In this design, a combinational logic block calculates the next value of every signal based on the current state and inputs, while the sequential logic (flip-flops) only updates the <code>reg</code> values on the rising edge of the clock.</p>

    <div class="image-container">
        <img src="images/image3.png" alt="Registered State Machine Diagram">
        <p class="figure-caption">Figure 2: Registered State Machine conceptual architecture diagram</p>
    </div>

    <p>By registering the state and outputs, we effectively isolate the combinational delays from the rest of the system, preventing "glitches" from propagating to the output pins and ensuring the design meets timing requirements at higher clock frequencies.</p>

    <p>In order to get a better understanding of the transmitter we will look at the following block diagram illustrating its internal design:</p>
    
    <div class="image-container">
        <img src="images/uart_int_sig.png" alt="UART Internal Signals Diagram">
        <p class="figure-caption">Figure 3: Internal logic blocks including FSM Control, Counter, and Shift Register</p>
    </div>
    

    <ul>
        <li>The <strong>FSM Control Unit</strong> acts as the brain, orchestrating the transition between states, and controlling the transmission done output, the baud enable signal, and the shifts of the shift register.</li>
        <li>The <strong>Counting Logic</strong> unit counts the <code>sample_tick</code> signal from the baud generator giving the timing for the FSM Control Unit.</li>
        <li>The <strong>Shift Register</strong> is the muscle, holding the parallel data and shifting it out bit-by-bit to the <code>tx_out</code> pin whenever the FSM signals that a full bit period has elapsed.</li>
    </ul>

    <p>From this diagram we can see all the internal signals needed for our module:</p>
    <ul>
        <li><strong>Output Logic and Register:</strong> Holds the state of the serial line to ensure a clean, stable output.</li>
        <li><strong>Tick Counter:</strong> Tracks the number of sample ticks received to determine when a full bit period has passed.</li>
        <li><strong>Bit Counter:</strong> Tracks the number of data bits transmitted to know when to move to the STOP state.</li>
        <li><strong>Transmit Data Register:</strong> A shift register used to store the parallel input and shift it out serially.</li>
        <li><strong>Transmission Done Signal:</strong> Logic to generate the handshake pulse for the CPU.</li>
        <li><strong>Baud Enable Signal:</strong> Logic to trigger the external Baud Rate Generator.</li>
    </ul>

    <details>
        <summary>View Internal Signals</summary>
<pre><code class="language-systemverilog">
    // Internal signals
    // 1. output logic and register
    logic tx_next; 
    logic tx_reg; 

    // 2. tick counter (0-TICKS_PER_BIT-1)
    logic [$clog2(TICKS_PER_BIT)-1:0] tick_count_next; 
    logic [$clog2(TICKS_PER_BIT)-1:0] tick_count_reg; 

    // 3. bit counter (0- DATA_WIDTH -1)
    logic [$clog2(DATA_WIDTH)-1:0] bit_count_next; 
    logic [$clog2(DATA_WIDTH)-1:0] bit_count_reg; 

    // 4. transmit data combinational and register logic
    logic [DATA_WIDTH-1:0] tx_data_next; 
    logic [DATA_WIDTH-1:0] tx_data_reg; 

    // 5. transmission done signal
    logic tx_done_next;
    logic tx_done_reg;

    // 6. baud enable signal
    logic baud_en_next;
    logic baud_en_reg;
</code></pre>
    </details>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">
    
    <h4>3. The State Machine Logic</h4>
    <p>The UART transmitter operates as a Finite State Machine (FSM). It transitions between four distinct states based on the <code>sample_tick</code> counter.</p>
    <p>This FSM is considered a <strong>Sequencer</strong> because its behavior follows a strict, predetermined path once it leaves the initial state. In many FSMs, multiple inputs might branch the logic into different directions; however, this transmitter is essentially a "one-way street." There is only one external control input (<code>tx_start</code>) that influences the state transitions, and it only affects the machine when it is in the IDLE state.</p>
    <p>The following diagram illustrates our FSM:</p>
    
    <div class="image-container">
        <img src="images/image4.png" alt="FSM State Diagram">
        <p class="figure-caption">Figure 4: FSM Transition Diagram</p>
    </div>
    

    <p>To manage these transitions in SystemVerilog, we define an enumerated type for the states. This makes the code more readable and allows the synthesis tool to optimize the state encoding.</p>
 <details>   
<summary>View State Definition code</summary>
<pre><code class="language-systemverilog">
// State machine states definition
typedef enum logic [1:0] {
    IDLE,
    START,
    DATA,
    STOP
} state_t; 

state_t state_next;
state_t state_reg;
</code></pre>
</details>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">  
    
    <h4>4. Implementation</h4>
    <p>The implementation follows the Two-Block RTL Style, separating the hardware into its <strong>Sequential Logic</strong> and <strong>Combinational Logic</strong> components.</p>
    <p>This separation is standard in professional hardware design for several reasons:</p>
    <ul>
        <li><strong>Timing Predictability:</strong> By separating the memory from the logic, it is much easier for Synthesis tools to optimize timing paths.</li>
        <li><strong>Readability:</strong> It creates a clear distinction between "What the state is" (Registers) and "How the state changes" (Logic).</li>
        <li><strong>Debugging:</strong> If a signal behaves unexpectedly, the designer can immediately tell if the error lies in the transition logic or the physical flip-flop update.</li>
    </ul>

    <h4>Sequential Logic</h4>
    <p><strong>Objective:</strong> The goal of this block is to physically implement the registers (Flip-Flops). On every rising edge of the clock, this block copies the "calculated" next values into the "current" registers. It also handles the system reset, ensuring the transmitter starts in a known, safe state <code>(IDLE)</code>.</p>

    <details>
        <summary>View Sequential Logic Code</summary>
<pre><code class="language-systemverilog">
    // Sequential Logic: Register Updates
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state_reg      <= IDLE;
            tx_reg         <= 1'b1; // Idle high
            tick_count_reg <= '0;
            bit_count_reg  <= '0;
            tx_data_reg    <= '0;
            tx_done_reg    <= 1'b0;
            baud_en_reg    <= 1'b0;
        end else begin
            state_reg      <= state_next;
            tx_reg         <= tx_next;
            tick_count_reg <= tick_count_next;
            bit_count_reg  <= bit_count_next;
            tx_data_reg    <= tx_data_next;
            tx_done_reg    <= tx_done_next;
            baud_en_reg    <= baud_en_next;
        end
    end
</code></pre>
    </details>

    <h4>Combinational Logic</h4>
    <p>This block acts as the "intelligence" of the module, calculated inside an <code>always_comb</code> block. We divide this logic into two functional segments:</p>
    
    <p><strong>1. Default Assignments:</strong> Before entering the state machine logic, we assign every <code>_next</code> signal a default value (usually its current <code>_reg</code> value). This is a critical safety measure in RTL design. It prevents the unintended creation of latches, which occur if a combinational path is not defined for every possible condition. By setting defaults first, we ensure every signal has a valid value even if no state-specific logic applies.</p>
    <p><strong>Baud Enable signal:</strong> for the <code>baud_en</code>signal we will use a more specific assignment, making sure it is kept low when the machine is in <code>IDLE</code> state, and switched to high for all other states</p>

    <details>
        <summary>View Default Assignments Code</summary>
<pre><code class="language-systemverilog">
    // 1. Default assignments (prevent latches)
    always_comb begin
        state_next      = state_reg;
        tx_next         = tx_reg;
        tick_count_next = tick_count_reg;
        bit_count_next  = bit_count_reg;
        tx_data_next    = tx_data_reg;
        tx_done_next    = 1'b0;               // Pulse only in specific states
        baud_en_next    = (state_reg != IDLE); // Only enable baud gen when busy
</code></pre>
    </details>

    <p><strong>2. State Machine Logic:</strong> in the same <code>always_comb</code> block we start a case statement for our states:</p>

    <p><strong>State 1: IDLE</strong><br>
    The line is held high (Logic 1). The FSM waits for the <code>tx_start</code> signal. When detected, it loads the input data into <code>tx_data_reg</code>, clears the tick counter, and moves to the START state.</p>
 <details>
        <summary>View <code>IDLE</code> State Code</summary>
<pre><code class="language-systemverilog">
            IDLE: begin
                tx_next = 1'b1;
                if (tx_start) begin
                    state_next      = START;
                    tx_data_next    = din;
                    tick_count_next = '0;
                end
            end
</code></pre>
</details>

    <p><strong>State 2: START</strong><br>
    The output line <code>tx_next</code> is pulled low (Logic 0). The machine waits for exactly 16 <code>sample_tick</code> pulses (one full bit duration). This signals the receiver that a transmission has begun.</p>
 <details>
        <summary>View <code>START</code> State Code</summary>
<pre><code class="language-systemverilog">
            START: begin
                tx_next = 1'b0;
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        state_next      = DATA;
                        tick_count_next = '0;
                        bit_count_next  = '0;
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end
</code></pre>
</details>
    <p><strong>State 3: DATA</strong><br>
    For each of the 8 bits, the LSB is placed on the output line for 16 ticks. After 16 ticks, the register shifts right to bring the next bit to the LSB position and increments the <code>bit_count</code>. After all bits are sent, it moves to STOP.</p>
 <details>
        <summary>View <code>DATA</code> State Code</summary>
<pre><code class="language-systemverilog">
            DATA: begin
                tx_next = tx_data_reg[0];
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        tick_count_next = '0;
                        if (bit_count_reg == DATA_WIDTH - 1) begin
                            state_next     = STOP;
                        end else begin
                            bit_count_next = bit_count_reg + 1;
                            tx_data_next   = tx_data_reg >> 1; // Shift Right
                        end
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end
</code></pre>
</details>
    <p><strong>State 4: STOP</strong><br>
    The line is pulled high (Logic 1) for 16 ticks. Once complete, the <code>tx_done</code> pulse is generated for one cycle, and the FSM returns to IDLE to wait for new data.</p>
 <details>
        <summary>View <code>STOP</code> State Code</summary>
<pre><code class="language-systemverilog">
            STOP: begin
                tx_next = 1'b1;
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        state_next      = IDLE;
                        tx_done_next    = 1'b1; // Pulse done handshake
                        tick_count_next = '0;
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end
        endcase
    end
</code></pre>
</details>
    <h4>Final Output Assignments</h4>
    <p>These simple continuous assignments link our stable, registered values to the physical output pins of the module.</p>
 <details>
        <summary>View Continuous Assignment Code:</summary>
<pre><code class="language-systemverilog">
    assign tx_out   = tx_reg;
    assign tx_done  = tx_done_reg;
    assign baud_en  = baud_en_reg;

endmodule
</code></pre>
</details>

    <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 40px 0;">
    
<h4>The Consolidated UART Code</h4>
    <details>
        <summary>View Full Module Code: uart_tx.sv</summary>
<pre><code class="language-systemverilog">
module uart_tx #(
    parameter TICKS_PER_BIT = 16,
    parameter DATA_WIDTH    = 8
) (
    input  logic                   clk,
    input  logic                   rst_n,
    input  logic [DATA_WIDTH-1:0]  din,
    input  logic                   tx_start,
    input  logic                   sample_tick,
    output logic                   tx_out,
    output logic                   tx_done,
    output logic                   baud_en
);

    // State machine states definition
    typedef enum logic [1:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state_reg, state_next;

    // Internal signals
    logic tx_reg, tx_next;
    logic [$clog2(TICKS_PER_BIT)-1:0] tick_count_reg, tick_count_next;
    logic [$clog2(DATA_WIDTH)-1:0] bit_count_reg, bit_count_next;
    logic [DATA_WIDTH-1:0] tx_data_reg, tx_data_next;
    logic tx_done_reg, tx_done_next;
    logic baud_en_reg, baud_en_next;

    // Sequential Logic: Register Updates
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state_reg      <= IDLE;
            tx_reg         <= 1'b1;
            tick_count_reg <= '0;
            bit_count_reg  <= '0;
            tx_data_reg    <= '0;
            tx_done_reg    <= 1'b0;
            baud_en_reg    <= 1'b0;
        end else begin
            state_reg      <= state_next;
            tx_reg         <= tx_next;
            tick_count_reg <= tick_count_next;
            bit_count_reg  <= bit_count_next;
            tx_data_reg    <= tx_data_next;
            tx_done_reg    <= tx_done_next;
            baud_en_reg    <= baud_en_next;
        end
    end

    // Combinational Logic: Next State and Output Logic
    always_comb begin
        // Default assignments
        state_next      = state_reg;
        tx_next         = tx_reg;
        tick_count_next = tick_count_reg;
        bit_count_next  = bit_count_reg;
        tx_data_next    = tx_data_reg;
        tx_done_next    = 1'b0;
        baud_en_next    = (state_reg != IDLE);

        case (state_reg)
            IDLE: begin
                tx_next = 1'b1;
                if (tx_start) begin
                    state_next      = START;
                    tx_data_next    = din;
                    tick_count_next = '0;
                end
            end

            START: begin
                tx_next = 1'b0;
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        state_next      = DATA;
                        tick_count_next = '0;
                        bit_count_next  = '0;
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end

            DATA: begin
                tx_next = tx_data_reg[0];
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        tick_count_next = '0;
                        if (bit_count_reg == DATA_WIDTH - 1) begin
                            state_next     = STOP;
                        end else begin
                            bit_count_next = bit_count_reg + 1;
                            tx_data_next   = tx_data_reg >> 1;
                        end
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end

            STOP: begin
                tx_next = 1'b1;
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        state_next      = IDLE;
                        tx_done_next    = 1'b1;
                        tick_count_next = '0;
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end
        endcase
    end

    // Output assignments
    assign tx_out  = tx_reg;
    assign tx_done = tx_done_reg;
    assign baud_en = baud_en_reg;

endmodule
</code></pre>
    </details>

  

    <h3>Building the Subsystem</h3>
    <p>To create a fully functional UART communication link, the Transmitter and the Baud Rate Generator must operate as a unified subsystem. While we have designed them as separate, modular components, they cannot fulfill their purpose in isolation. In the next stage of our development, we will create a new SystemVerilog file for our UART Subsystem. This top-level module will instantiate both the baud generator and the transmitter, physically wiring them together to form a complete serial transmission engine ready for integration into a larger FPGA or SoC design.</p>
</div>




<!-- IMAGE ZOOM OVERLAY LOGIC -->
<div id="imageModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); cursor: pointer; align-items: center; justify-content: center;" onclick="closeModal(event)">
    <span style="position: absolute; top: 20px; right: 35px; color: #fff; font-size: 40px; font-weight: bold; cursor: pointer;">&times;</span>
    <img id="img01" style="margin: auto; display: block; width: 80%; max-width: 1000px; border-radius: 8px; border: 2px solid #30363d; transition: transform 0.1s ease-out; transform-origin: center;">
</div>

<script>
    const modal = document.getElementById("imageModal");
    const modalImg = document.getElementById("img01");
    let currentScale = 1;

    // 1. Select ALL images with 'zoom-trigger'
    const allZoomImages = document.querySelectorAll(".zoom-trigger");

    allZoomImages.forEach(img => {
        img.addEventListener('click', function() {
            // Force the display to flex so it centers and shows up
            modal.style.setProperty("display", "flex", "important");
            modalImg.src = this.src;
            currentScale = 1; 
            modalImg.style.transform = `scale(${currentScale})`;
        });
    });

    // 2. Close modal function
    function closeModal(event) {
        // Only close if clicking the background or the 'X' (span), not the image
        if (event.target !== modalImg) {
            modal.style.display = "none";
        }
    }

    // 3. Scroll to Zoom Logic
    modal.addEventListener('wheel', function(e) {
        // Only zoom if modal is actually visible
        if (modal.style.display === "flex") {
            e.preventDefault(); 

            const zoomStep = 0.15; // Slightly faster zoom
            if (e.deltaY < 0) {
                currentScale += zoomStep;
            } else {
                currentScale -= zoomStep;
            }

            // Restrict zoom levels
            currentScale = Math.min(Math.max(0.5, currentScale), 5);

            modalImg.style.transform = `scale(${currentScale})`;
        }
    }, { passive: false });
    
    </script>
    <script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</body>
</html>