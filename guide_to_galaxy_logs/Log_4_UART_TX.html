---
layout: null
---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log 4: The UART Transmitter</title>
   <style>
        :root {
            --space-black: #0b0e14;
            --deep-slate: #161b22;
            --nebula-purple: #6e40c9;
            --star-blue: #58a6ff;
            --stardust: #e6edf3;
            --border-color: #30363d;
            --code-bg: #0d1117;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--stardust);
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: radial-gradient(circle at center, #1a1f2e 0%, var(--space-black) 100%);
            background-attachment: fixed;
        }
        h1, h2, h3, h4 { color: var(--star-blue); margin-top: 1.5em; }
        
        .log-container {
            background-color: var(--deep-slate);
            padding: 40px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* SECTION STYLING */
        .section {
            padding-bottom: 20px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }
        .section:last-of-type { border-bottom: none; }

        .back-link { 
            margin-bottom: 20px; 
            display: inline-block; 
            text-decoration: none; 
            color: var(--nebula-purple); 
            font-weight: bold; 
            transition: color 0.2s;
        }
        .back-link:hover { color: var(--star-blue); }
        
        details {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }
        summary { cursor: pointer; font-weight: bold; color: var(--star-blue); outline: none; }
        pre { 
            white-space: pre-wrap; 
            word-wrap: break-word; 
            font-family: 'Consolas', 'Courier New', monospace; 
            font-size: 14px; 
            color: #d1d5db;
            margin: 0;
        }
        code { background: #21262d; padding: 2px 5px; border-radius: 4px; color: var(--star-blue); font-family: 'Consolas', monospace; }
        ul { padding-left: 20px; }
        li { margin-bottom: 8px; }
        blockquote { border-left: 4px solid var(--nebula-purple); margin: 20px 0; padding-left: 15px; font-style: italic; }
        a { color: var(--star-blue); text-decoration: none; }
        a:hover { text-decoration: underline; }

        /* Interface Table Styling */
        .interface-table-wrapper {
            overflow: hidden;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin: 20px 0;
            background: #ffffff;
        }
        .interface-table {
            width: 100%;
            border-collapse: collapse;
            color: #1e293b;
        }
        .interface-table th {
            background-color: #f8fafc;
            padding: 12px 16px;
            text-align: left;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #475569;
            border-bottom: 1px solid #e2e8f0;
        }
        .interface-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            font-size: 0.875rem;
        }
        .interface-table tr:hover { background-color: #f8fafc; }
        .signal-name {
            font-family: 'Consolas', monospace;
            font-weight: 600;
            color: #2563eb;
        }

        /* Image Zoom Styling */
        .clickable-img {
            cursor: zoom-in;
            transition: transform 0.2s;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            border-radius: 8px;
        }
        .clickable-img:hover { transform: scale(1.01); }
        .img-caption { color: #8b949e; font-size: 0.85rem; margin-top: 10px; font-style: italic; }

        /* --- ADDITIONS FOR ENLARGING & ZOOMING --- */
        .img-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: none; /* Controlled by Script */
            justify-content: center;
            align-items: center;
            z-index: 9999;
            cursor: zoom-out;
            overflow: hidden; /* Prevents scrollbars during zoom */
        }

        .img-overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            transition: transform 0.1s ease-out; /* Smooth scrolling zoom */
            transform-origin: center; /* Ensures zoom happens from middle */
        }
    </style>
</head>
<body>

<div class="log-container">
    <a href="https://tomerhabany.github.io/Chip_design_journey/" class="back-link">← Back to Portfolio</a>
    <div class="section">
        <h1 class="center">Log 4: The UART Transmitter – Precision Timing & State Machines</h1>
        <p>In our previous log, we mastered data buffering with the FIFO. Now, we will build the bridge that sends that data out of our chip. We are moving into communication protocols, starting with the UART (Universal Asynchronous Receiver-Transmitter). Specifically, we will focus on the Transmitter (TX) side.</p>
    </div>

    <div class="section">
        <h2>What is a UART?</h2>
        <p>UART will be the "translator" of our digital world. Inside our chip, the CPU works with parallel data, sending 8 bits all at once across 8 wires. However, most external devices only have one wire to listen on. Our UART’s job will be to take that parallel byte and "serialize" it, sending it out bit-by-bit over time.</p>

        <h3>The Life of a Transmission: A Step-by-Step Example</h3>
        <p>Imagine our CPU wants to send the letter 'A' (ASCII 8'h41, or binary 01000001). Here is exactly how we will handle the flow:</p>
        
        <ul class="step-list">
            <li>The Trigger: <span>The CPU will place 8'b01000001 on the din bus and pulse a start transmission signal - 'tx_start'.</span></li>
            <li>The Wake-up (Start Bit): <span>The UART will immediately pull the output wire - 'tx_out' from High to Low ('0'). This tells the receiver, "Pay attention, data is coming!"</span></li>
            <li>The Data Payload: <span>The UART will then send each bit of the 'A' one by one. It will start with the Least Significant Bit (LSB) and end with the MSB.</span></li>
            <li>The Close (Stop Bit): <span>After all 8 bits are sent, the UART will pull the line back to High ('1'). This resets the line for the next message.</span></li>
            <li>The Finish Line: <span>The UART will pulse a feedback signal - 'tx_done' to let the CPU know it can send the next character.</span></li>
        </ul>

        <p>Every transmission will follow this '0' -> Data -> '1' frame.</p>
    </div>

    <div class="section">
        <h3>Controlling the Timing: The 16x Over-Sampling Concept</h3>
        <p>How will we ensure the receiver doesn't miss a bit? We will use a concept called Over-sampling. We won't just send a bit and hope for the best; we will divide the time for a single bit (the Bit Period) into 16 smaller segments called sample_tick pulses.</p>

        <p>Our UART will hold the value of each bit on tx_out for exactly 16 of these ticks. We do this because the receiver on the other end is designed to wait for the 8th tick - the dead center of the bit to sample the value. By holding our bit for 16 ticks, we give the receiver the best possible chance to capture the data accurately, even if there is slight clock drift.</p>

        
        <div class="image-placeholder">
            <img src="images/image1.png" alt="UART Block Diagram">
            Image 1: UART Block Diagram 
        </div>
        <p>This diagram shows the high-level flow from the CPU, through our UART and Baud Generator blocks, out to the Receiver.</p>
    </div>

    <div class="section">
        <h2>Deep Dive 1: The Baud Rate Generator</h2>
        <p>To get those 16 ticks per bit, we will need a heartbeat. This will be our Baud Rate Generator.</p>

        <h3>The Logic: Why we won't let it run free</h3>
        <p>We don't want our baud_gen to be free-running; instead, we want it to only be enabled when a transmission starts.</p>

        <p>If the generator is free-running, it is constantly counting in the background. If the tx_start signal arrives just as the generator was about to finish a count, our first bit (the Start Bit) might be cut extremely short. In a worst-case scenario, the '0' bit that signals the start of communication would only be a few clock cycles wide instead of the full 16-tick period. This would cause the receiver to miss the message entirely. By using a baud_en signal from the UART, we will "reset" the timer so it starts fresh at the exact moment we begin sending data.</p>

        <div class="image-placeholder">
            <img src="images/image2.png" alt="Baud Generator Timing Diagram">
            Image 2: Timing Diagram showing worst case scenario for free running baud generator
        </div>
        <p>This illustrates the timing collision that happens if we don't synchronize the generator.</p>

        <h3>Implementation: Step-by-Step</h3>
        <p><strong>Step 1: Defining the Interface and the Math</strong> We will start by defining our parameters. We need the CLOCK_FREQ of our board and the BAUD_RATE we want to achieve. We will then use a localparam to calculate the TICK_LIMIT. This limit tells our counter exactly how many system clock cycles must pass to equal one sample_tick.</p>

        <details>
            <summary>View Code: Interface and Math</summary>
            <pre>
module baud_gen #(
    parameter CLOCK_FREQ = 100_000_000,
    parameter BAUD_RATE  = 115200
)(
    input  logic clk, rst_n, en,
    output logic sample_tick
);
    // Formula: System Clock / (Desired Baud * 16 ticks per bit)
    localparam TICK_LIMIT = CLOCK_FREQ / (BAUD_RATE * 16);
    logic [$clog2(TICK_LIMIT)-1:0] count;
            </pre>
        </details>

        <p><strong>Step 2: The Counting Logic</strong> Now we will implement the actual counter. When en is high, the counter will increment. Once it hits the TICK_LIMIT, it will pulse the sample_tick for exactly one clock cycle and wrap back to zero. If en is low, the counter will be held at zero, ensuring we are perfectly synchronized for the next start bit.</p>

        <details>
            <summary>View Code: Counting Logic</summary>
            <pre>
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            count <= 0;
            sample_tick <= 0;
        end else if (en) begin
            if (count == TICK_LIMIT - 1) begin
                count <= 0;
                sample_tick <= 1;
            end else begin
                count <= count + 1'b1;
                sample_tick <= 0;
            end
        end else begin
            count <= 0;
            sample_tick <= 0;
        end
    end
endmodule
            </pre>
        </details>
    </div>

    <div class="section">
        <h2>Deep Dive 2: The UART TX Controller</h2>
        <p>Now that we have our baud_gen to control the timing, we can start working on the UART_TX itself. This will be the "Brain" of the operation.</p>

        <h3>Designing for Stability: The Registered Moore Machine</h3>
        <p>We will implement a Moore State Machine, where the output is determined solely by the current state. To ensure our output is perfectly stable and free of combinational logic "glitches," we will make it a Registered State Machine. This means we will use a register to hold the state, ensuring that the tx_out signal only changes exactly on the clock edge.</p>

        <div class="image-placeholder">
            <img src="images/image3.png" alt="State Register Block Diagram">
            Image 3: Registered State Machine Block Diagram 
        </div>
        
    </div>

    <div class="section">
        <h3>The Philosophy of Registered State Machines</h3>
        <p>As we move into professional-grade RTL, we will adopt the industry-standard practice of separating our logic into two distinct domains. For every signal that controls our output—the state, the data buffer, and internal counters—we will create a <code>_next</code> (combinational) and a <code>_reg</code> (sequential) pair.</p>

        <ul>
            <li><strong>Combinational Logic (<code>_next</code>):</strong> This acts as the "brain," calculating the next value based on current inputs and the current state.</li>
            <li><strong>Sequential Logic (<code>_reg</code>):</strong> This acts as the "memory," latching those values exactly on the clock edge.</li>
        </ul>

        <p>We are doing this to separate the combinational logic from the sequential logic. This is the industry standard because it prevents electrical "glitches" (tiny, unwanted pulses) from appearing on our output pins and ensures our design can meet strict timing requirements. By latching the next state into a register, our signals remain stable and clean for the rest of the hardware.</p>
    </div>

    <div class="section">
        <h3>Engineering Specification: <code>uart_tx.sv</code></h3>

        <h4>1. Parameters and Ports</h4>
        <p>We will define the interface of our sequencer. We use <code>TICKS_PER_BIT</code> (typically 16) and <code>DATA_WIDTH</code> (8 bits) as parameters to make the module reusable. Our ports include the system clock, reset, and the control signals from the CPU, the pulse from the Baud Generator and the Baud enable signal.</p>

        <details>
            <summary>View Code: Parameters and Ports</summary>
            <pre>
module uart_tx
#(
    parameter TICKS_PER_BIT = 16, 
    parameter DATA_WIDTH    = 8   
)
(
    input  logic clk,
    input  logic rst_n,
    input  logic [DATA_WIDTH-1:0] din,
    input  logic tx_start,
    input  logic sample_tick,
    output logic tx_out,
    output logic tx_done,
    output logic baude_en
);
            </pre>
        </details>

        <h4>2. Internal Signals</h4>
        <p>We will declare the registers and their corresponding combinational "next" signals. Every internal signal that controls our output generation—including the <code>tick_count_reg</code> (to track the 16 ticks) and <code>bit_count_reg</code> (to track which of the 8 bits we are sending)—will have a matching <code>_next</code> signal. We use <code>$clog2</code> to determine the exact number of bits needed for our counters to save hardware area.</p>

        <details>
            <summary>View Code: Internal Signals</summary>
            <pre>
    // 1. output logic and register
    logic tx_next; 
    logic tx_reg; 

    // 2. tick counter (0-TICKS_PER_BIT-1)
    logic [$clog2(TICKS_PER_BIT)-1:0] tick_count_next; 
    logic [$clog2(TICKS_PER_BIT)-1:0] tick_count_reg; 

    // 3. bit counter (0- DATA_WIDTH -1)
    logic [$clog2(DATA_WIDTH)-1:0] bit_count_next; 
    logic [$clog2(DATA_WIDTH)-1:0] bit_count_reg; 

    // 4. transmit data combinational and register logic
    logic [DATA_WIDTH-1:0] tx_data_next; 
    logic [DATA_WIDTH-1:0] tx_data_reg; 

    // 5. transmission done signal
    logic tx_done_next;
    logic tx_done_reg;

    // 6. baude enable signal
    logic baude_en_next;
    logic baude_en_reg;
            </pre>
        </details>

        <h4>3. State Machine Sequential Logic</h4>
        <p>We will use an <code>typedef enum</code> to define our states. This replaces "magic numbers" with human-readable labels (<code>IDLE</code>, <code>START</code>, <code>DATA</code>, <code>STOP</code>), making the FSM logic easy to follow and debug.</p>

        <details>
            <summary>View Code: State Machine Enum</summary>
            <pre>
typedef enum logic [1:0] {
    IDLE,
    START,
    DATA,
    STOP
} state_t; 
state_t state_next;
state_t state_reg;
            </pre>
        </details>

        <h4>4. Combinational Assignments</h4>
        <p>We will link our physical output ports directly to our internal registers. This ensures that the outside world only sees the stable, latched values from our registers.</p>

        <details>
            <summary>View Code: Combinational Assignments</summary>
            <pre>
assign tx_out = tx_reg;
assign tx_done = tx_done_reg;
assign baude_en = baude_en_reg;
            </pre>
        </details>

        <h4>5. Sequential Logic</h4>
        <p>This is the only section where we use the <code>posedge clk</code>. On a reset (<code>rst_n</code> low), we will initialize our registers to safe values—specifically, <code>tx_reg</code> will be set to '1' (the idle state). On every clock edge, we will simply move the "next" values into the "registers."</p>

        <details>
            <summary>View Code: Sequential Logic</summary>
            <pre>
always_ff @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
        state_reg <= IDLE;
        tx_reg <= 1'b1;
        tick_count_reg <= '0;
        bit_count_reg <= '0;
        tx_data_reg <= '0;
        tx_done_reg <= 1'b0;
        baude_en_reg <= 1'b0;
    end else begin
        state_reg <= state_next;
        tx_reg <= tx_next;
        tick_count_reg <= tick_count_next;
        bit_count_reg <= bit_count_next;
        tx_data_reg <= tx_data_next;
        tx_done_reg <= tx_done_next;
        baude_en_reg <= baude_en_next;
    end
end
            </pre>
        </details>

        <h4>6. Combinational Logic</h4>
        <p>In this block, we will define the defaults to prevent "latches." We will ensure <code>baude_en_next</code> is automatically high whenever we are not in <code>IDLE</code>, which keeps our timing generator active exactly when we need it.</p>

        <details>
            <summary>View Code: Combinational Logic Defaults</summary>
            <pre>
always_comb begin
     state_next = state_reg;
     tx_next = tx_reg;
     tick_count_next = tick_count_reg;
     bit_count_next = bit_count_reg;
     tx_data_next = tx_data_reg;
     tx_done_next = 1'b0; 
     baude_en_next = (state_reg != IDLE);
            </pre>
        </details>
    </div>

    <div class="section">
        <h4>7. State Machine Case Logic</h4>
        <p>We will implement the sequencer using a <code>case</code> statement. Our controller will follow the pre-determined path: <code>IDLE</code> -> <code>START</code> -> <code>DATA</code> -> <code>STOP</code>. In each state, we will count 16 <code>sample_tick</code> pulses before moving to the next. In the <code>DATA</code> state, we will use the right-shift operator (<code>>></code>) to move the next bit into position every time a bit period finishes.</p>

        
        <div class="image-placeholder">
            <img src="images/image4.png" alt="FSM State Diagram">
            Image 4: UART FSM/Sequencer state diagram 
        </div>
        <p>The visual sequence of our UART states.</p>

        <details>
            <summary>View Code: State Machine Logic</summary>
            <pre>
     case(state_reg)
        IDLE: begin
            tx_next = 1'b1;
            if (tx_start) begin
                state_next = START;
                tx_data_next = din; 
                tick_count_next = '0;
            end
        end   

        START: begin
            tx_next = 1'b0; 
            if (sample_tick) begin
                if (tick_count_reg == TICKS_PER_BIT - 1) begin
                    state_next = DATA;
                    tick_count_next = '0;
                    bit_count_next = '0;
                end else begin
                    tick_count_next = tick_count_reg + 1;
                end
            end
        end

        DATA: begin 
            tx_next = tx_data_reg[0];
            if (sample_tick) begin
                if (tick_count_reg == TICKS_PER_BIT - 1) begin
                    tick_count_next = '0; 
                    if (bit_count_reg == DATA_WIDTH - 1) begin
                        state_next = STOP;
                        bit_count_next = '0;
                    end else begin
                        bit_count_next = bit_count_reg + 1;
                        tx_data_next = tx_data_reg >> 1; 
                    end
                end else begin
                    tick_count_next = tick_count_reg + 1;
                end
            end
        end

        STOP: begin
            tx_next = 1'b1; 
            if (sample_tick) begin
                if (tick_count_reg == TICKS_PER_BIT - 1) begin
                    state_next = IDLE;
                    tx_done_next = 1'b1;
                    tick_count_next = '0;
                end else begin
                    tick_count_next = tick_count_reg + 1;
                end
            end
        end
    endcase
end
            </pre>
        </details>
    </div>

    <div class="section">
        <hr>
        <h3>Complete Code: <code>uart_tx.sv</code></h3>
        <p>Here is the full implementation, combining all the steps above into a single, clean module that we can copy-paste into our project.</p>

        <details>
            <summary>View Full <code>uart_tx.sv</code> Code</summary>
            <pre>
`timescale 1ns / 1ps
module uart_tx
#(
    parameter TICKS_PER_BIT = 16, 
    parameter DATA_WIDTH    = 8   
)
(
    input  logic clk,
    input  logic rst_n,
    input  logic [DATA_WIDTH-1:0] din,
    input  logic tx_start,
    input  logic sample_tick,
    output logic tx_out,
    output logic tx_done,
    output logic baude_en
);

    typedef enum logic [1:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state_next;
    state_t state_reg;

    logic tx_next; 
    logic tx_reg; 
    logic tx_done_next;
    logic tx_done_reg;
    logic baude_en_next;
    logic baude_en_reg;

    logic [$clog2(TICKS_PER_BIT)-1:0] tick_count_next; 
    logic [$clog2(TICKS_PER_BIT)-1:0] tick_count_reg; 
    logic [$clog2(DATA_WIDTH)-1:0] bit_count_next; 
    logic [$clog2(DATA_WIDTH)-1:0] bit_count_reg; 
    logic [DATA_WIDTH-1:0] tx_data_next; 
    logic [DATA_WIDTH-1:0] tx_data_reg; 

    assign tx_out   = tx_reg;
    assign tx_done  = tx_done_reg;
    assign baude_en = baude_en_reg;

    always_ff @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            state_reg      <= IDLE;
            tx_reg         <= 1'b1;
            tick_count_reg <= '0;
            bit_count_reg  <= '0;
            tx_data_reg    <= '0;
            tx_done_reg    <= 1'b0;
            baude_en_reg   <= 1'b0;
        end else begin
            state_reg      <= state_next;
            tx_reg         <= tx_next;
            tick_count_reg <= tick_count_next;
            bit_count_reg  <= bit_count_next;
            tx_data_reg    <= tx_data_next;
            tx_done_reg    <= tx_done_next;
            baude_en_reg   <= baude_en_next;
        end
    end

    always_comb begin
         state_next      = state_reg;
         tx_next         = tx_reg;
         tick_count_next = tick_count_reg;
         bit_count_next  = bit_count_reg;
         tx_data_next    = tx_data_reg;
         tx_done_next    = 1'b0; 
         baude_en_next   = (state_reg != IDLE);

         case(state_reg)
            IDLE: begin
                tx_next = 1'b1;
                if (tx_start) begin
                    state_next      = START;
                    tx_data_next    = din;
                    tick_count_next = '0;
                end
            end   

            START: begin
                tx_next = 1'b0;
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        state_next      = DATA;
                        tick_count_next = '0;
                        bit_count_next  = '0;
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end

            DATA: begin 
                tx_next = tx_data_reg[0];
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        tick_count_next = '0;
                        if (bit_count_reg == DATA_WIDTH - 1) begin
                            state_next     = STOP;
                            bit_count_next = '0;
                        end else begin
                            bit_count_next = bit_count_reg + 1;
                            tx_data_next   = tx_data_reg >> 1;
                        end
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end

            STOP: begin
                tx_next = 1'b1;
                if (sample_tick) begin
                    if (tick_count_reg == TICKS_PER_BIT - 1) begin
                        state_next      = IDLE;
                        tx_done_next    = 1'b1;
                        tick_count_next = '0;
                    end else begin
                        tick_count_next = tick_count_reg + 1;
                    end
                end
            end
         endcase
    end
endmodule
            </pre>
        </details>
    </div>
    <a href="https://tomerhabany.github.io/Chip_design_journey/" class="back-link">← Back to Portfolio</a>
</div>
    // <!-- IMAGE ZOOM OVERLAY LOGIC -->
<div id="imageModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); cursor: pointer; align-items: center; justify-content: center;" onclick="closeModal(event)">
    <span style="position: absolute; top: 20px; right: 35px; color: #fff; font-size: 40px; font-weight: bold; cursor: pointer;">&times;</span>
    <img id="img01" style="margin: auto; display: block; width: 80%; max-width: 1000px; border-radius: 8px; border: 2px solid #30363d; transition: transform 0.1s ease-out; transform-origin: center;">
</div>

<script>
    const modal = document.getElementById("imageModal");
    const modalImg = document.getElementById("img01");
    let currentScale = 1;

    // 1. Select ALL images with 'zoom-trigger'
    const allZoomImages = document.querySelectorAll(".zoom-trigger");

    allZoomImages.forEach(img => {
        img.addEventListener('click', function() {
            // Force the display to flex so it centers and shows up
            modal.style.setProperty("display", "flex", "important");
            modalImg.src = this.src;
            currentScale = 1; 
            modalImg.style.transform = `scale(${currentScale})`;
        });
    });

    // 2. Close modal function
    function closeModal(event) {
        // Only close if clicking the background or the 'X' (span), not the image
        if (event.target !== modalImg) {
            modal.style.display = "none";
        }
    }

    // 3. Scroll to Zoom Logic
    modal.addEventListener('wheel', function(e) {
        // Only zoom if modal is actually visible
        if (modal.style.display === "flex") {
            e.preventDefault(); 

            const zoomStep = 0.15; // Slightly faster zoom
            if (e.deltaY < 0) {
                currentScale += zoomStep;
            } else {
                currentScale -= zoomStep;
            }

            // Restrict zoom levels
            currentScale = Math.min(Math.max(0.5, currentScale), 5);

            modalImg.style.transform = `scale(${currentScale})`;
        }
    }, { passive: false });
</script>


</body>
</html>