---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log 2: The Architecture of Addition</title>
    <style>
        :root {
            --space-black: #0b0e14;
            --deep-slate: #161b22;
            --nebula-purple: #6e40c9;
            --star-blue: #58a6ff;
            --stardust: #e6edf3;
            --border-color: #30363d;
            --code-bg: #0d1117;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--stardust);
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: radial-gradient(circle at center, #1a1f2e 0%, var(--space-black) 100%);
            background-attachment: fixed;
        }
        h1, h2, h3, h4 { color: var(--star-blue); margin-top: 1.5em; }
        
        .log-container {
            background-color: var(--deep-slate);
            padding: 40px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .section {
            padding-bottom: 20px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }
        .section:last-of-type { border-bottom: none; }

        .back-link { 
            margin-bottom: 20px; 
            display: inline-block; 
            text-decoration: none; 
            color: var(--nebula-purple); 
            font-weight: bold; 
            transition: color 0.2s;
        }
        .back-link:hover { color: var(--star-blue); }
        
        details {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }
        summary { cursor: pointer; font-weight: bold; color: var(--star-blue); outline: none; }
        pre { 
            white-space: pre-wrap; 
            word-wrap: break-word; 
            font-family: 'Consolas', 'Courier New', monospace; 
            font-size: 14px; 
            color: #d1d5db;
            margin: 0;
        }
        code { background: #21262d; padding: 2px 5px; border-radius: 4px; color: var(--star-blue); font-family: 'Consolas', monospace; }
        ul { padding-left: 20px; }
        li { margin-bottom: 8px; }
        blockquote { border-left: 4px solid var(--nebula-purple); margin: 20px 0; padding-left: 15px; font-style: italic; }
        .subtitle { color: #8b949e; font-style: italic; margin-top: -10px; margin-bottom: 20px; }
    </style>
</head>
<body>

<div class="log-container">
    <a href="https://tomerhabany.github.io/Chip_design_journey/" class="back-link">← Back to Portfolio</a>
    
    <h1 class="center"> Log 2: The Architecture of Addition</h1>
    <p class="subtitle">A Journey from Fresh Graduate to Silicon Engineer<br>
    Moving from behavioral modeling to structural hardware design.</p>
    
    <div class="section">
        <h3>The Mission: Structural Integration</h3>
        <p>In Log 2, we move from behavioral modeling (letting the tools decide the logic) to <strong>Structural Modeling</strong>. We are building a <strong>Parameterizable Ripple Carry Adder (RCA)</strong>. This log isn't just about addition; it's about learning how to build a scalable system from small, verified sub-modules.</p>
    </div>

    <div class="section">
        <h3>Part 1: The Leaf Cell (adder_1bit.sv)</h3>
        <p><strong>The Goal:</strong> Build a "Full Adder"—the smallest unit of addition. It takes two bits (a, b) and a "Carry-In" (cin), then outputs a <em>sum</em> and a <em>cout</em>.</p>

        

        <blockquote>
            <strong>Important Note:</strong> Adding <code>#1</code> delays makes this code <strong>non-synthesizable</strong>. In real production RTL, you wouldn't include these because timing is determined by physical silicon. For simulation, they are vital for visualizing the "ripple" effect.
        </blockquote>

        <details>
            <summary>Source: rtl/adder_1bit.sv</summary>
            <pre><code>
`timescale 1ns/1ps
module adder_1bit (
    input logic  a, b, cin,
    output logic sum, cout
);
    // These #1 delays are for simulation only!
    assign #1 sum  = a ^ b ^ cin;
    assign #1 cout = (a & b) | (cin & (a ^ b));
endmodule
            </code></pre>
        </details>
    </div>

    <div class="section">
        <h3>Part 2: The Scalable Top-Level (rca.sv)</h3>
        <p><strong>The Goal:</strong> Chain 1-bit adders to handle larger numbers using a design that scales automatically based on a <code>WIDTH</code> variable.</p>

        

        <details>
            <summary>Source: rtl/rca.sv</summary>
            <pre><code>
module rca #( parameter WIDTH = 8 ) (
    input  logic [WIDTH-1:0] a, b,
    input  logic             cin,
    output logic [WIDTH-1:0] sum,
    output logic             cout
);
    // The Carry Chain: Connecting the overflow between bits
    logic [WIDTH:0] carry_chain;
    assign carry_chain[0] = cin;

    genvar i;
    generate
        for (i = 0; i < WIDTH; i = i + 1) begin : adder_loop
            adder_1bit u_adder_1bit (
                .a   (a[i]),
                .b   (b[i]),
                .cin (carry_chain[i]),
                .sum (sum[i]),
                .cout(carry_chain[i+1])
            );
        end
    endgenerate

    assign cout = carry_chain[WIDTH];
endmodule
            </code></pre>
        </details>
    </div>

    <div class="section">
        <h3>Part 3: The Automated Testbench (tb_rca.sv)</h3>
        <p><strong>The Goal:</strong> Verify 16-bit math by comparing our structural <strong>RCA module</strong> against <strong>SystemVerilog’s built-in + operator</strong> reference.</p>
        
        <details>
            <summary>Source: dv/tb_rca.sv</summary>
            <pre><code>
initial begin
    repeat (20) begin
        a = 16'($urandom_range(0, 2**WIDTH-1));
        b = 16'($urandom_range(0, 2**WIDTH-1));
        cin = 1'($urandom_range(0, 1));

        // Calculate a reference answer using the built-in operator
        expected_value = 17'(a) + 17'(b) + 17'(cin);
        
        #20; // The "Settling Time"

        // Compare our structural hardware vs the reference result
        if (sum !== expected_value[WIDTH-1:0] || cout !== expected_value[WIDTH])
            $error("Mismatch detected! Check the carry chain timing.");
        else
            $display("PASS: %0d + %0d = %0d", a, b, {cout, sum});
    end
end
            </code></pre>
        </details>
    </div>

    <div class="section">
        <h3>Log 2 Final Summary</h3>
        <ul>
            <li><strong>Structural Hierarchy:</strong> Successfully implemented a hierarchical design by nesting leaf cells within a top-module.</li>
            <li><strong>Scalability with Generics:</strong> Used <code>generate</code> loops to create a Parameterizable Design.</li>
            <li><strong>Simulation Timing Realism:</strong> Integrated inertial delays to model propagation delay.</li>
            <li><strong>Automated Self-Checking:</strong> Developed a "Golden Reference" testbench strategy for 100% accuracy.</li>
        </ul>
        
    </div>
    <a href="https://tomerhabany.github.io/Chip_design_journey/" class="back-link">← Back to Portfolio</a>
</div>

</body>
</html>