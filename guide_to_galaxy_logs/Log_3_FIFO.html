---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log 3: The Synchronous FIFO</title>
    <style>
        :root {
            --space-black: #0b0e14;
            --deep-slate: #161b22;
            --nebula-purple: #6e40c9;
            --star-blue: #58a6ff;
            --stardust: #e6edf3;
            --border-color: #30363d;
            --code-bg: #0d1117;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--stardust);
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: radial-gradient(circle at center, #1a1f2e 0%, var(--space-black) 100%);
            background-attachment: fixed;
        }
        h1, h2, h3, h4 { color: var(--star-blue); margin-top: 1.5em; }
        
        .log-container {
            background-color: var(--deep-slate);
            padding: 40px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .section {
            padding-bottom: 20px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
        }
        .section:last-of-type { border-bottom: none; }

        .back-link { 
            margin-bottom: 20px; 
            display: inline-block; 
            text-decoration: none; 
            color: var(--nebula-purple); 
            font-weight: bold; 
            transition: color 0.2s;
        }
        .back-link:hover { color: var(--star-blue); }
        
        details {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }
        summary { cursor: pointer; font-weight: bold; color: var(--star-blue); outline: none; }
        pre { 
            white-space: pre-wrap; 
            word-wrap: break-word; 
            font-family: 'Consolas', 'Courier New', monospace; 
            font-size: 14px; 
            color: #d1d5db;
            margin: 0;
        }
        code { background: #21262d; padding: 2px 5px; border-radius: 4px; color: var(--star-blue); font-family: 'Consolas', monospace; }
        ul { padding-left: 20px; }
        li { margin-bottom: 8px; }
        .subtitle { color: #8b949e; font-style: italic; margin-top: -10px; margin-bottom: 20px; text-align: center; }
        .center { text-align: center; }
    </style>
</head>
<body>

<div class="log-container">
    <a href="index.html" class="back-link">‚Üê Back to Portfolio</a>
    
    <h1 class="center">üåå Log 3: The Synchronous FIFO</h1>
    <p class="subtitle">Moving from combinational gates to sequential buffering logic.</p>
    
    <div class="section">
        <h3>The Mission: Sequential Logic & Buffering</h3>
        <p>In Log 2, we built an adder where signals "rippled" through gates. Now, we move into <strong>Sequential Logic</strong>. We are building a <strong>Synchronous FIFO (First-In, First-Out)</strong>. Think of this as the "waiting room" of digital design - a buffer used to manage data flow between different modules.</p>
    </div>

    <div class="section">
        <h2> The Module (<code>fifo.sv</code>)</h2>
        <h3>Ô∏è 1. The Interface and Memory Array</h3>
        <p>We need a storage buffer that handles data in order. Our first step is defining the interface and the physical storage shelves (memory array) using parameters for scalability.</p>

        

        <details>
            <summary>Source: rtl/fifo.sv (Interface)</summary>
            <pre><code>
module fifo #(
    parameter DATA_WIDTH = 8,
    parameter DEPTH = 16
)(
    input  logic clk,
    input  logic rst_n,
    input  logic wr_en,
    input  logic rd_en,
    input  logic [DATA_WIDTH-1:0] din,
    output logic [DATA_WIDTH-1:0] dout,
    output logic full,
    output logic empty,
    output logic almost_full,
    output logic almost_empty
);
    logic [DATA_WIDTH-1:0] mem [0:DEPTH-1];
    localparam PTR_WIDTH = $clog2(DEPTH);
    logic [PTR_WIDTH-1:0] wr_ptr, rd_ptr;
    logic [PTR_WIDTH:0] count; 
endmodule
            </code></pre>
        </details>
    </div>

    <div class="section">
        <h3> 2. Status Flags (The Early Warning System)</h3>
        <p>We implement <strong>Almost Full/Empty</strong> flags. In high-speed designs, these act as an <strong>Early Warning</strong>, telling the sender to "Slow down" before an actual overflow occurs.</p>

        <details>
            <summary>Source: rtl/fifo.sv (Flags)</summary>
            <pre><code>
    assign full         = (count == (PTR_WIDTH+1)'(DEPTH));
    assign empty        = (count == 0);
    assign almost_full  = (count >= (PTR_WIDTH+1)'(DEPTH - 2)); 
    assign almost_empty = (count <= 2);
            </code></pre>
        </details>
    </div>

    <div class="section">
        <h3> 3. Control Logic (Pointers & Counter)</h3>
        <p>We manage pointers using a <strong>Circular Buffer</strong> strategy‚Äîwrapping back to zero when the last shelf is reached.</p>

        <details>
            <summary>Source: rtl/fifo.sv (Control Logic)</summary>
            <pre><code>
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            wr_ptr <= 0; rd_ptr <= 0; count <= 0;
        end else begin
            if (wr_valid) wr_ptr <= (wr_ptr == (PTR_WIDTH)'(DEPTH-1)) ? 0 : wr_ptr + 1'b1;
            if (rd_valid) rd_ptr <= (rd_ptr == (PTR_WIDTH)'(DEPTH-1)) ? 0 : rd_ptr + 1'b1;
            case ({wr_valid, rd_valid})
                2'b10: count <= count + 1'b1;
                2'b01: count <= count - 1'b1;
            endcase
        end
    end
            </code></pre>
        </details>
    </div>

    <div class="section">
        <h3> The Automated Testbench</h3>
        <p>We verify the hardware using a <strong>Golden Reference Queue</strong> in SystemVerilog. By mirroring every hardware move in software, we can automatically detect data mismatches.</p>

        <details>
            <summary>Source: dv/tb_fifo.sv (Tasks)</summary>
            <pre><code>
    task read_data();
        expected_data = queue.pop_front(); 
        @(negedge clk);
        rd_en = 1;
        @(negedge clk);
        rd_en = 0;
        if (dout !== expected_data) 
            $error("Data mismatch! Expected: %h, Got: %h", expected_data, dout);
    endtask
            </code></pre>
        </details>
    </div>

    <div class="section">
        <h3>üìù Log 3 Final Summary</h3>
        <ul>
            <li><strong>RTL Design:</strong> Implemented a Parameterized Synchronous FIFO with Early Warning flags.</li>
            <li><strong>Automated Verification:</strong> Used SystemVerilog Tasks and a Golden Reference Queue for 100% data checking.</li>
            <li><strong>Stress Testing:</strong> Verified throughput, overflow (Full), and underflow (Empty) scenarios.</li>
        </ul>
        <p class="center"><i>Log 3 Complete.</i></p>
    </div>
</div>

</body>
</html>